//
//  AuthorizationInteractor.swift
//  L-Tech-test
//
//  Created by Рамил Гаджиев on 20.10.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

protocol AuthorizationBusinessLogic {
    func startSettings()
    func fetchModels()
    func checkUser(request: Authorization.checkUser.Request)
}

protocol AuthorizationDataStore {
    var models: [MyDetailScreenModel]? { get set }
    var maskNumber: MaskNumberModel? { get set }
}

class AuthorizationInteractor: AuthorizationBusinessLogic, AuthorizationDataStore {
    

    var maskNumber: MaskNumberModel?
    var models: [MyDetailScreenModel]? = []
    
    var presenter: AuthorizationPresentationLogic?
    var worker: AuthorizationWorker?
    
    
    
    func checkUser(request: Authorization.checkUser.Request) {
        let number = request.number.replacingOccurrences(of: "[^0-9]", with: "", options: .regularExpression)
        let password = request.password
        let maskNumber = request.maskNumber
        let request = Authorization.checkUser.Request(number: number, password: password, maskNumber: maskNumber)
        let userData = UserModel(phone: request.number, password: request.password)
        NetworkManager.shared.auth(userModel: userData) {[weak self] (result) in
            switch result {
            case .success(let bool):
                if bool {
                    let user = KeyChainModel(number: number, password: password, maskNumber: maskNumber)
                    KeychainHelper.standard.save(user, service: "access-user", account: "test")
                    self?.fetchModels()
                    print("user saved in KeyChain")
                } else {
                    let response = Authorization.checkUser.Response(error: Errors.authProblem)
                    self?.presenter?.presentErrorCheckUserAlert(response: response)
                }
            case .failure(let error):
                let response = Authorization.checkUser.Response(error: error)
                self?.presenter?.presentErrorCheckUserAlert(response: response)
            }
        }
    }
    
    
    func startSettings() {
        guard let user = KeychainHelper.standard.read(service: "access-user", account: "test", type: KeyChainModel.self) else {
            NetworkManager.shared.getMaskNumber {[weak self] (result) in
                switch result {
                case .success(let data):
                    let response = Authorization.getMaskNumber.Response(maskNumber: data, error: nil)
                    self?.presenter?.presentMaskNumber(response: response)
                case .failure(let error):
                    let response = Authorization.getMaskNumber.Response(maskNumber: nil, error: error)
                    self?.presenter?.presentErrorMaskNumberAlert(response: response)
                }
            }
            return
        }
        let response = Authorization.fetchUser.Response(user: user)
        presenter?.presentUser(response: response)
    }
    
    
    func fetchModels() {
        let worker = AuthorizationWorker()
        worker.fetchModels { [weak self] models in
            self?.models = models
            self?.presenter?.readyToMove()
        }
    }
  
}
